# 第一章 用函数构建抽象

## 名称和环境

- 在 Python 中，可以使用赋值语句来建立新的绑定，它包含`=`左边的名称和右边的值。


- 名称也可以通过`import`语句绑定：


```py
>>> from math import pi
>>> pi * 71 / 223
1.0002380197528042
```

- 也可以在一个语句中将多个值赋给多个名称，其中名称和表达式由逗号分隔：


```py
>>> area, circumference = pi * radius * radius, 2 * pi * radius
```

赋值是 Python 中的最简单的抽象手段，因为它使我们可以使用最简单的名称来引用复合操作的结果。

将名称绑定到值上，以及随后通过名称来检索这些值的可能，意味着解释器必须维护某种内存来跟踪这些名称和值的绑定。这些内存叫做**环境**。

名称也可以绑定到函数。例如，名称`max`绑定到了我们曾经用过的`max`函数上。可以使用赋值运算符来给现有函数起新的名字：

```py
>>> f = max
>>> f
<built-in function max>
>>> f(3, 4)
4
```

在 Python 中，通过赋值绑定的名称通常叫做变量名称，因为它们在执行程序期间可以绑定到许多不同的值上面。

## 嵌套表达式的求解

为了求出调用的表达式，Python 会执行下列事情：

+ 求出运算符和**操作数子表达式**
+ 根据**操作数子表达式**的值，作为参数调用主调函数

第一步表明为了完成调用表达式的求值过程，我们首先必须求出其它表达式。

例如，求出

```py
>>> mul(add(2, mul(4, 6)), add(3, 5))
208
```

需要应用四次求值过程。内层函数计算完毕后，再计算外层函数。

## 函数

> 前置知识：函数调用栈、变量作用域

**签名：**`abs`函数值接受一个叫作`number`的参数，向它提供更多或更少的参数会产生错误。`print`函数可以接受任意数量的参数，所以它渲染为`print(...)`。函数的可接受参数的描述叫做函数的签名。

现在我们将要了解函数定义，一个更加强大的抽象技巧，名称通过它可以绑定到复合操作上，并可以作为一个单元来引用。例如：

```py
>>> def square(x):
        return mul(x, x)
```

这定义了一个新的函数，并赋予了名称`square`。定义中的`x`叫做形式参数，它为被乘的东西提供一个名称。这个定义创建了用户定义的函数，并且将它关联到名称`square`上。

## 高阶函数

代码中会反复出现一些常见的编程模式，但是使用一些不同函数来实现。这些模式也可以被抽象和给予名称。比如计算：
$$
\text{Sum}=f(1)+f(2)+...+f(n)
$$
甚至加法也可以看作一种二元函数，即
$$
\text{Sum}=g...g(g(g(f(n),f(n-1)),f(n-2)),f(n-3))...
$$
为了给上面这种“编程模式”一个具体的概念，我们需要构造可以接受其他函数作为参数的函数，或者将函数作为返回值的函数。操作函数的函数叫做**高阶函数**。

### Lambda表达式

Python 中，我们可以使用 Lambda 表达式创建匿名函数。Lambda 表达式是函数体具有单个返回表达式的函数，不允许出现赋值和控制语句。

Lambda 表达式十分受限：它们仅仅可用于简单的单行函数，求解和返回一个表达式。在它们适用的特殊情形中，Lambda 表达式具有强大的表现力。

```py
>>> def compose1(f,g):
        return lambda x: f(g(x))
```

我们可以通过构造相应的英文语句来理解 Lambda 表达式：

```py
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

一些程序员发现使用 Lambda 表达式作为匿名函数非常简短和直接。但是，复合的 Lambda 表达式非常难以辨认，尽管它们很简洁。

```py
>>> compose1 = lambda f,g: lambda x: f(g(x))
```

通常，Python 的代码风格倾向于显式的`def`语句而不是 Lambda 表达式，但是允许它们在简单函数作为参数或返回值的情况下使用。

这种风格规范不是准则，你可以想怎么写就怎么写，但是，在你编写程序时，要考虑某一天可能会阅读你的程序的人们。如果你可以让你的程序更易于理解，你就帮了人们一个忙。

## 示例：Church

### Part I

1. 累乘函数

   ```python
   def product(n, f):
       # Omitted...
       return ans
   ```

   $$
   \text{Ans}=f(1)*f(2)*...*f(n)
   $$

2. 积累函数

   ```python
   def accumulate(combiner, base, n, f):
       ans, i = base, 1
       while (i<=n):
           ans = combiner(ans, f(i))
           i += 1
       return ans
   ```

   由`combiner`函数取代累乘函数中的二元运算$*$。
   $$
   \text{Ans}=c(...c(c(c(b,f(1)),f(2)),f(3))...,f(n))
   $$
   则如果要计算$f(1)+f(2)+...+f(n)$，只需调用`accumulate(add, 0, n, f)`；如果要计算$f(1)*f(2)*...*f(n)$，只需调用`accumulate(mul, 1, n, f)`。

3. 复合函数

   ```python
   def compose(h, g):
       def f(x):
           return h(g(x))
       return f
   ```

   $n$重复合函数

   ```python
   def make_repeater(h, n):
       return accumulate(compose, identity, n, lambda k: h)
   ```

   这里`identity = lambda x: x`。

### Part II

```python
def zero(f):
    return lambda x: x

def successor(n):
    return lambda f: lambda x: f(n(f)(x))

def one(f):
    """Church numeral 1: same as successor(zero)"""
    return lambda x: f(x)

def two(f):
    """Church numeral 2: same as successor(successor(zero))"""
    return lambda x: f(f(x))

three = successor(two)
```

- 这里的zero, one, two是算子，可以看成是将一个算子映射为另一个算子。
  $$
  \begin{aligned}
  \text{zero}:f→g,&\text{ }g(x)=x\\
  \text{one}:f→g,&\text{ }g(x)=f(x)\\
  \text{two}:f→g,&\text{ }g(x)=f(f(x))
  \end{aligned}
  $$

- 于是这里的successor可以看成算子的生成，给定算子的层级$n$和基础算子$f$，它将$n$级算子映射到$n+1$级算子。
  $$
  \text{successor}:f^n→g,\text{ }g(x)=f^{n+1}(x)
  $$
  根据前面的定义，$n$级算子就是`n(f)`。

### Part III

1. **将邱奇数$n$转化为普通整数。**

   即对整数0（Base）作用加1的$n$级算子。

   `n(lambda x: x + 1)(0)`

2. **对两个邱奇数$m,n$做加法。**

   即对$n$级算子再做$m$次successor运算。

   `lambda f: lambda x: m(f)(n(f)(x))`

3. **对两个邱奇数$m,n$做乘法。**

   调用$m$次$n(f)$，就相当于做了$mn$次successor运算。

   `lambda f: m(n(f))`

4. **计算邱奇数$m^n$。**

   感觉涉及到形式化的知识了，以后理解了再填坑。

   `n(m)`