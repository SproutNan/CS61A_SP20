# 第二章 用数据构建抽象

在这门课的开始，我们区分了函数和数据：函数执行操作，而数据被操作。当我们在数据中包含函数值时，我们承认数据也拥有行为。函数可以像数据一样被操作，但是**也可以被调用来执行计算**。

Python 中万物皆对象。

Python 中每个对象都拥有一个类型。`type`函数可以让我们查看对象的类型。

## 数据抽象

### 示例：有理数

将有理数表示为整数的比值，能够完全避免近似问题。出于精确，我们希望将分子和分母分离，但是将它们看做一个单元。

### 元组

为了具体实现我们的数据抽象，Python 提供了一种复合数据结构叫做`tuple`，它可以由逗号分隔的值来构造。圆括号通常在元组周围。

实际上，多重赋值的本质是创建和解构元组。

与元素选择操作等价的函数叫做`__getitem__`，它也使用位置在元组中选择元素，位置的下标以 0 开始。

```py
>>> from operator import getitem
>>> getitem(pair, 0)
1
```

## 序列

序列是数据值的顺序容器。不像偶对只有两个元素，序列可以拥有任意（但是有限）个有序元素。序列不是特定的抽象数据类型，而是不同类型共有的一组行为。特别地，有**长度**和**元素选择器**。

### 递归链表

采用类似广义表的结构，由一系列偶对表示。每个偶对的第一个元素是列表中的元素，而第二个元素是用于表示列表其余部分的偶对。最后一个偶对的第二个元素是`None`，它表明列表到末尾了。我们可以使用嵌套的元组字面值来构造这个结构：

```py
>>> (1, (2, (3, (4, None))))
(1, (2, (3, (4, None))))
```

这个嵌套的结构通常对应了一种非常实用的序列思考方式。**一个非空序列可以划分为它的第一个元素，以及序列的其余部分**。我们将序列的这种看法叫做递归，因为序列包含其它序列作为第二个组成部分。

### 元组II

实际上，`tuple`类型本身就是完整的序列类型，本质上提供了更多功能。

元组具有任意的长度，并且也拥有序列抽象的两个基本行为：长度和元素选择。下面的`digits`是一个四元素元组。

```py
>>> digits = (1, 8, 2, 8)
>>> len(digits)
4
>>> digits[3]
8
```

此外，元素可以彼此相加以及与整数相乘。对于元组，加法和乘法操作并不对元素相加或相乘，而是组合和重复元组本身。

```py
>>> (2, 7) + digits * 2
(2, 7, 1, 8, 2, 8, 1, 8, 2, 8)
```

### 映射

将一个元组变换为另一个元组的强大手段是在每个元素上调用函数，并收集结果。这一计算的常用形式叫做在序列上映射函数，对应内建函数`map`。`map`的结果是一个本身不是序列的对象，但是可以通过调用`tuple`来转换为序列。它是元组的构造器。

```py
>>> alternates = (-1, 2, -3, 4, -5)
>>> tuple(map(abs, alternates))
(1, 2, 3, 4, 5)
```

`map`函数非常重要，因为它依赖于序列抽象：我们不需要关心底层元组的结构，只需要能够独立访问每个元素，以便将它作为参数传入用于映射的函数中（这里是`abs`）。

## 接口约定

### 生成器表达式

生成器表达式组合了过滤和映射的概念，并集成于单一的表达式中：

```
<map expression> for <name> in <sequence expression> if <filter expression>
```

为了求出生成器表达式，Python 先求出`<sequence expression>`，它必须返回一个可迭代值。之后，对于每个元素，按顺序将元素值绑定到`<name>`，求出过滤器表达式，如果它产生真值，就会求出映射表达式。

生成器表达式的求解结果值本身是个可迭代值。累计函数，比如`tuple`、`sum`、`max`和`min`可以将返回的对象作为参数。

```py
>>> def acronym(name):
        return tuple(w[0] for w in name.split() if iscap(w))
>>> def sum_even_fibs(n):
        return sum(fib(k) for k in range(1, n+1) if fib(k) % 2 == 0)
```

生成器表达式是使用可迭代（例如序列）接口约定的特化语法。这些表达式包含了`map`和`filter`的大部分功能，但是避免了被调用函数的实际创建（或者，顺便也避免了环境帧的创建需要调用这些函数）。

### 规约

函数式编程语言（包括 Python）包含通用的高阶累加器，具有多种名称。Python 在`functools`模块中包含`reduce`，它对序列中的元素从左到右依次调用二元函数，将序列归约为一个值。下面的表达式计算了五个因数的积。

```py
>>> from operator import mul
>>> from functools import reduce
>>> reduce(mul, (1, 2, 3, 4, 5))
120
```

